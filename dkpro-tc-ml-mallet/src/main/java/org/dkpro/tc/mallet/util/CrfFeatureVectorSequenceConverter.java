/*******************************************************************************
 * Copyright 2015
 * Ubiquitous Knowledge Processing (UKP) Lab
 * Technische Universit√§t Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package org.dkpro.tc.mallet.util;

import org.dkpro.tc.core.Constants;

import cc.mallet.pipe.Pipe;
import cc.mallet.types.Alphabet;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.FeatureVectorSequence;
import cc.mallet.types.Instance;
import cc.mallet.types.LabelAlphabet;
import cc.mallet.types.LabelSequence;

/**
 * Modification of SimpleTagger2FeatureVectorSequence from Mallet
 */

public class CrfFeatureVectorSequenceConverter
    extends Pipe
{

    private int idFeatureIndex;

    // Previously, there was no serialVersionUID. This is ID that would
    // have been automatically generated by the compiler. Therefore,
    // other changes should not break serialization.
    private static final long serialVersionUID = -2059308802200728625L;

    public CrfFeatureVectorSequenceConverter()
    {
        super(new Alphabet(), new LabelAlphabet());
        idFeatureIndex = -1;
    }

    /**
     * Parses a string representing a sequence of rows of tokens into an array of arrays of tokens
     * (Ignore first sentence containing feature names)
     *
     * @param sentence
     *            a <code>String</code>
     * @return the corresponding array of arrays of tokens.
     */
    private String[][] parseSentence(String sentence)
    {
        String[] lines = sentence.split("\n");
        String[][] tokens = null;
        if (lines[0].matches("^[A-Za-z]+.*$")) { // parsing first line group containing feature
                                                 // names
            String[] featureNames = lines[0].split(" ");
            for (int i = 0; i < featureNames.length; i++) {
                if (featureNames[i].equals(Constants.ID_FEATURE_NAME)) {
                    idFeatureIndex = i;
                }
            }
            if (idFeatureIndex != -1) { // if file contained the DKPro Instance ID feature
                tokens = new String[lines.length - 1][];
                String[][] tempTokens = new String[lines.length - 1][];
                for (int i = 1; i < lines.length; i++) {
                    tempTokens[i - 1] = lines[i].split(" ");
                }
                for (int i = 0; i < tempTokens.length; i++) {
                    tokens[i] = new String[tempTokens[i].length - 1];
                    int tokenLineIndex = 0;
                    for (int j = 0; j < tempTokens[i].length; j++) {
                        if (j != idFeatureIndex) {
                            tokens[i][tokenLineIndex++] = tempTokens[i][j];
                        }
                    }
                }
            }
            else {
                tokens = new String[lines.length - 1][];
                for (int i = 1; i < lines.length; i++) {
                    tokens[i - 1] = lines[i].split(" ");
                }
            }
        }
        else {
            if (idFeatureIndex != -1) { // if file contained the DKPro Instance ID feature
                tokens = new String[lines.length][];
                String[][] tempTokens = new String[lines.length][];
                for (int i = 0; i < lines.length; i++) {
                    tempTokens[i] = lines[i].split(" ");
                }
                for (int i = 0; i < tempTokens.length; i++) {
                    tokens[i] = new String[tempTokens[i].length - 1];
                    int tokenLineIndex = 0;
                    for (int j = 0; j < tempTokens[i].length; j++) {
                        if (j != idFeatureIndex) {
                            tokens[i][tokenLineIndex++] = tempTokens[i][j];
                        }
                    }
                }
            }
            else {
                tokens = new String[lines.length][];
                for (int i = 0; i < lines.length; i++) {
                    tokens[i] = lines[i].split(" ");
                }
            }
        }
        return tokens;
    }

    @Override
    public Instance pipe(Instance carrier)
    {
        Object inputData = carrier.getData();
        Alphabet features = getDataAlphabet();
        LabelAlphabet labels;
        LabelSequence target = null;
        String[][] tokens;
        if (inputData instanceof String)
            tokens = parseSentence((String) inputData);
        else if (inputData instanceof String[][])
            tokens = (String[][]) inputData;
        else
            throw new IllegalArgumentException("Not a String or String[][]; got " + inputData);
        FeatureVector[] fvs = new FeatureVector[tokens.length];
        if (isTargetProcessing()) {
            labels = (LabelAlphabet) getTargetAlphabet();
            target = new LabelSequence(labels, tokens.length);
        }
        for (int l = 0; l < tokens.length; l++) {
            int nFeatures;
            if (isTargetProcessing()) {
                if (tokens[l].length < 1)
                    throw new IllegalStateException(
                            "Missing label at line " + l + " instance " + carrier.getName());
                nFeatures = tokens[l].length - 1;
                target.add(tokens[l][nFeatures]);
            }
            else
                nFeatures = tokens[l].length;
            int featureIndices[] = new int[nFeatures];
            for (int f = 0; f < nFeatures; f++)
                featureIndices[f] = features.lookupIndex(tokens[l][f]);
            fvs[l] = new FeatureVector(features, featureIndices);
        }
        carrier.setData(new FeatureVectorSequence(fvs));
        if (isTargetProcessing())
            carrier.setTarget(target);
        return carrier;
    }

}